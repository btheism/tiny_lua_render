透视矩阵的推导:(假设近平面和远平面在右手系的坐标分别为-n,-f,摄像机在原点),(n,f均为正数)

把透视空间(棱锥)的点映射到正交空间(立方体)(此步完全在右手系中进行)
设映射前的点为(x,y,z,1),映射后的点为(x0,y0,z0,1)
则有:
每个点的z不变(z0=z)
近平面的(x,y)也不变(z=n时,x0=x,y0=y)
中间平面的(x,y)映射到(x0,y0),且根据相似三角形,x0/x=y0/y=(-n)/z(由于物体位于屏幕后方,在右手系下z<0,因此这个比例系数是正的)
==>x0=-n*x/z; y0=-n*y/z; z0=z
即(x,y,z,1)==>(-n*x/z,-n*y/z,z,1)
由于这个变换非线性,因此可以利用透视除法把z移出来
(-n*x/z,-n*y/z,z,1)=>(-n*x,-n*y,z^2,z)
这个变换还是非线性的(出现了z^2),由于在渲染时z只涉及到遮挡关系的判断,因此没必要把z变换为z^2,设z被变换为f(z),则透视除法后得到的点的z坐标为f(z)/z,我们只需保证f(z)/z单调递增即可(这样就可以不破坏遮挡关系)
因此变换矩阵有如下形式:(由于f(z)与x,y无关,因此矩阵第三行的前两项必须为0)
{{-n,0,0,0},{0,-n,0,0},{0,0,A,B},{0,0,1,0}}
其中f(z)=Az+b,f(z)/z=A+b/z,不妨取A=0,B=-1(-1/z单调递增)(在f(z)/z=A+b/z中,A是一个常数项,取值无所谓,B是反比例函数的系数,只要负号正确,取值也无所谓)
得到
M1=
{{-n,0,0,0},
{0,-n,0,0},
{0,0,0,-1},
{0,0,1,0}}
这样的话,我们把点(x,y,z,1)映射为(-n*x,-n*y,-1,z),透视除法后变为(-n*x/z,-n*y/z,-1/z,1)
我们原本的近平面和远平面(-n,-f)变为(1/n,1/f)
因此正交空间->NDC空间的矩阵变为:(代换了近平面和远平面的变量为-1/n,-1/f)
M2=
{{2/(r-l), 0, 0, -(r+l)/(r-l)},
{0, 2/(t-b), 0, -(t+b)/(t-b)},
{0, 0, -2/(1/n-1/f), (1/f+1/n)/(1/n-1/f)},
{0, 0, 0, 1}}
计算M2.M1,得到透视矩阵:
{{2*n/(l-r), 0, (l+r)/(l-r), 0},
{0, 2*n/(b-t), (b+t)/(b-t), 0},
{0, 0, (f+n)/(f-n), 2*f*n/(f-n)},
{0, 0, 1, 0}}

=>z'=((f+n)/(f-n)*z+2*f*n/(f-n))/z


该矩阵与http://www.songho.ca/opengl/gl_projectionmatrix.html的矩阵正好差一个负号,这意味着变换出来的4维坐标正好差一个负号,经过透视除法,最后得到的3维坐标是一致的

当输入角度(fov)和比例(aspect)时,(即近平面的top和bottom与原点的夹角为fov)
t=n*tan(fov/2)(正数)
b=-t;
r=aspect*t(正数)
l=-r;
得到透视矩阵(遵从传统,已经反转了矩阵的符号):
{{Cot[fov/2]/aspect, 0, 0, 0},
{0, Cot[fov/2], 0, 0},
{0, 0, -(f+n)/(f-n), -2*f*n/(f-n)},
{0, 0,-1, 0}}



